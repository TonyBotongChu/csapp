3.64
A.
12(%ebp) : s1.p
16(%ebp) : s1.v
8(%ebp) : result
思路如下：
由第8行可知12(%ebp)中存储的是地址，而此函数中出现的指针只有s1.p
由第11行imull为乘法，对应源代码中的*s1.p * s1.v，可知%ebx和%edx中有一个是*s1.p，另一个是s1.v。第8行已知%edx为*s1.p，因此%ebx为s1.v。再由第6行反推知16(%ebp)为s1.v
第9行为加法，因此%ecx对应result.sum，进而在函数结束时4(%eax)对应result.sum。再结合第11行可知result.prod最终保存到了(%eax)。可以推断%eax中保存的是result的起始地址，进而推断出8(%ebp)对应result
B.
从上到下（地址由高到低）
1:s2.sum
2:s2.prod
3:s1.v
4:s1.p
5:&s2
思路如下：
由第2行可知%ebp中存储着原%esp的值。如果把新分配的第一个字段标号为1，那么%ebp对应的标号就是0。
由第13，14行可知-8(%ebp)为s2.prod，-4(%ebp)为s2.sum。故字段1对应s2.sum，字段2对应s2.prod。
相似地，由第9,10行可以推断出s1。
字段5为word_sum的返回值。
C.
传递结构体参数与正常的传值相似。结构体的每一个变量在传入时可以看做是单独的参数。
D.
返回结构体的通用策略：将返回变量的地址看做第一个传入函数的参数。%eax充当返回变量的指针。

3.65
A=3，B=7
思路如下：
由第2行知8+4+2*B向上取4的倍数为28，可得B的值为7或8。
由第5行知2*A*B向上取4的整数倍为44，可得A*B的值为21或22。
由以上两个推论，再分解因子即可得到答案。
